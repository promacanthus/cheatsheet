<!DOCTYPE html>
<html lang="en">
<html class="dark light">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    

    
    
    
    <title>
         Rust
        
    </title>

        
            <meta property="og:title" content="Rust" />
        
     

     
         
     

     
         
    

    
    
        <link rel="icon" type="image/png" href=&#x2F;icon&#x2F;favicon.png />
    

    
    
        <link href=https://promacanthus.github.io/cheatsheet/fonts.css rel="stylesheet" />
    

    
    

    
    
        <script src=https://promacanthus.github.io/cheatsheet/js/codeblock.js></script>
    

    
    
        <script src=https://promacanthus.github.io/cheatsheet/js/toc.js></script>
    
    
    
    
        <script src=https://promacanthus.github.io/cheatsheet/js/note.js></script>
    

    
        
            <script>
            MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };
            </script>
        
        <script type="text/javascript" id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        </script>
    

    
    <link rel="alternate" type="application/atom+xml" title="" href="https://promacanthus.github.io/cheatsheet/atom.xml">


    
    
        <link rel="stylesheet" type="text/css" href=https://promacanthus.github.io/cheatsheet/theme/light.css />
        <link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://promacanthus.github.io/cheatsheet/theme/dark.css" />
    

    <!-- Set the correct theme in the script -->
    <script src=https://promacanthus.github.io/cheatsheet/js/themetoggle.js></script>
    
        <script>setTheme(getSavedTheme());</script>
    

    <link rel="stylesheet" type="text/css" media="screen" href=https://promacanthus.github.io/cheatsheet/main.css />

    
</head>


<body>
    <div class="content">
        <header>
    <div class="main">
        <a href=https:&#x2F;&#x2F;promacanthus.github.io&#x2F;cheatsheet></a>

        <div class="socials">
            
            <a rel="me" href="404.html" class="social">
                <img alt=twitter src=https://promacanthus.github.io/cheatsheet/social_icons/twitter.svg>
            </a>
            
            <a rel="me" href="https:&#x2F;&#x2F;github.com&#x2F;promacanthus&#x2F;" class="social">
                <img alt=github src=https://promacanthus.github.io/cheatsheet/social_icons/github.svg>
            </a>
            
            <a rel="me" href="404.html" class="social">
                <img alt=youtube src=https://promacanthus.github.io/cheatsheet/social_icons/youtube.svg>
            </a>
            
            <a rel="me" href="404.html" class="social">
                <img alt=linkedin src=https://promacanthus.github.io/cheatsheet/social_icons/linkedin.svg>
            </a>
            
            <a rel="me" href="&#x2F;index.xml" class="social">
                <img alt=rss src=https://promacanthus.github.io/cheatsheet/social_icons/rss.svg>
            </a>
            
            <a rel="me" href="404.html" class="social">
                <img alt=email src=https://promacanthus.github.io/cheatsheet/social_icons/email.svg>
            </a>
            
        </div>
    </div>

    <nav>
        
        <a href=https://promacanthus.github.io/cheatsheet style="margin-left: 0.5em">&#x2F;Home</a>
        
        <a href=https://promacanthus.github.io/cheatsheet/about style="margin-left: 0.5em">&#x2F;About</a>
        
        <a href=https://promacanthus.github.io/cheatsheet/rust style="margin-left: 0.5em">&#x2F;Rust</a>
        

        
        |<a id="dark-mode-toggle" onclick="toggleTheme(); event.preventDefault();" href="#">
            <img src=https://promacanthus.github.io/cheatsheet/feather/sun.svg id="sun-icon" style="filter: invert(1);" alt="Light" />
            <img src=https://promacanthus.github.io/cheatsheet/feather/moon.svg id="moon-icon" alt="Dark" />
        </a>

        <!-- Inititialize the theme toggle icons -->
        <script>updateItemToggleTheme()</script>
        
    </nav>
</header>


        
        
    
<main>
    <article>
        <div class="title">
            
            
    <div class="page-header">
        Rust<span class="primary-color" style="font-size: 1.6em">.</span>
    </div>


                <div class="meta">
                    

                    

                    

                    
                    

                    
                    

                    

                </div>
        </div>

        

        
        
        
            <div class="toc-container">
                <h1 class="toc-title">Table of Contents</h1>
                <ul class="toc-list">
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#jie-shao">介绍</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#zhu-shi">注释</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#ge-shi-hua-shu-chu">格式化输出</a>
                                        </li>

                                        
                                            <ul>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#format">format!</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#write">write!</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#print">print!</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#format-args">format_args!</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#debug">Debug</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#display">Display</a>
                                                    </li>
                                                
                                            </ul>
                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#shu-ju-lei-xing">数据类型</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#yuan-sheng-lei-xing">原生类型</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#zi-mian-liang">字面量</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#yuan-zu">元组</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#shu-zu-he-qie-pian">数组和切片</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#lei-xing-zhuan-huan">类型转换</a>
                                        </li>

                                        
                                            <ul>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#from-into">From&#x2F;Into</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#tryfrom-tryinto">TryFrom&#x2F;TryInto</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#tostring">ToString</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#fromstr">FromStr</a>
                                                    </li>
                                                
                                            </ul>
                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#jie-gou-ti-he-mei-ju">结构体和枚举</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#struct">struct</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#enum">enum</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#chang-liang">常量</a>
                                        </li>

                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#bian-liang">变量</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#dong-jie">冻结</a>
                                        </li>

                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#kong-zhi-liu">控制流</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#if-else">if&#x2F;else</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#xun-huan">循环</a>
                                        </li>

                                        
                                            <ul>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#loop">loop</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#while">while</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#for">for</a>
                                                    </li>
                                                
                                            </ul>
                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#match">match</a>
                                        </li>

                                        
                                            <ul>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#mo-shi-pi-pei">模式匹配</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#jie-gou-pi-pei">解构匹配</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#shou-wei">守卫</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#bang-ding">绑定</a>
                                                    </li>
                                                
                                            </ul>
                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#if-let">if let</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#while-let">while let</a>
                                        </li>

                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#han-shu">函数</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#fang-fa">方法</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#bi-bao">闭包</a>
                                        </li>

                                        
                                            <ul>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#bu-huo-bian-liang">捕获变量</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#zuo-wei-shu-ru-he-shu-chu-can-shu">作为输入和输出参数</a>
                                                    </li>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#bi-bao-zhong-mo-shi-pi-pei">闭包中模式匹配</a>
                                                    </li>
                                                
                                            </ul>
                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#gao-jie-han-shu">高阶函数</a>
                                        </li>

                                        
                                            <ul>
                                                
                                                    <li>
                                                        <a href="https://promacanthus.github.io/cheatsheet/rust/#fa-san-han-shu">发散函数</a>
                                                    </li>
                                                
                                            </ul>
                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#suo-you-quan-he-jie-yong">所有权和借用</a>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#te-zheng-traits">特征（Traits）</a>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#cuo-wu-chu-li">错误处理</a>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#fan-xing">泛型</a>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#mo-kuai-xi-tong">模块系统</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#mod-guan-jian-zi">mod 关键字</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#use-yu-ju">use 语句</a>
                                        </li>

                                        
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#pub-guan-jian-zi">pub 关键字</a>
                                        </li>

                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#chang-yong-biao-zhun-ku-gong-neng">常用标准库功能</a>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#shu-xing">属性</a>
                            
                                <ul>
                                    
                                        <li>
                                            <a href="https://promacanthus.github.io/cheatsheet/rust/#cfg">cfg</a>
                                        </li>

                                        
                                    
                                </ul>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#hong">宏</a>
                            
                        </li>
                    
                        <li>
                            <a href="https://promacanthus.github.io/cheatsheet/rust/#yi-bu-bian-cheng">异步编程</a>
                            
                        </li>
                    
                </ul>
            </div>
        
        

        <section class="body">
            <p>Rust 速查手册（Rust Cheatsheet）是一个非常有用的工具，可以帮助开发者快速回顾 Rust 的核心概念和语法。以下是一个简单的 Rust 速查手册大纲，涵盖了一些常见的 Rust 特性：</p>
<h2 id="jie-shao">介绍</h2>
<h3 id="zhu-shi">注释</h3>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 单行注释
</span><span>
</span><span style="color:#65737e;">/* 
</span><span style="color:#65737e;"> * 多行注释
</span><span style="color:#65737e;"> */
</span><span>
</span><span style="color:#65737e;">/// 文档注释
</span></code></pre>
<h3 id="ge-shi-hua-shu-chu">格式化输出</h3>
<p><code>std::fmt</code> 中定义的宏，用于格式化和打印 Strings 的实用工具。</p>
<h4 id="format"><code>format!</code></h4>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>format!(&quot;</span><span style="color:#a3be8c;">Hello</span><span>&quot;);                 </span><span style="color:#65737e;">// =&gt; &quot;Hello&quot;
</span><span style="color:#65737e;">// 使用 Display 格式，`{}` 以优雅且有好的方式格式化文本。
</span><span>format!(&quot;</span><span style="color:#a3be8c;">Hello, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">world</span><span>&quot;);   </span><span style="color:#65737e;">// =&gt; &quot;Hello, world!&quot;
</span><span>format!(&quot;</span><span style="color:#a3be8c;">The number is </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#d08770;">1</span><span>);   </span><span style="color:#65737e;">// =&gt; &quot;The number is 1&quot;
</span><span style="color:#65737e;">// 使用 Debug 格式，`:?` 指示符会以调试格式输出值。
</span><span>format!(&quot;</span><span style="color:#d08770;">{:?}</span><span>&quot;, (</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>));          </span><span style="color:#65737e;">// =&gt; &quot;(3, 4)&quot;
</span><span style="color:#65737e;">// 使用命名参数格式化，在格式字符串中使用变量名，然后在参数列表中提供对应的值。
</span><span>format!(&quot;</span><span style="color:#d08770;">{value}</span><span>&quot;, value=</span><span style="color:#d08770;">4</span><span>);      </span><span style="color:#65737e;">// =&gt; &quot;4&quot;
</span><span>
</span><span style="color:#b48ead;">let</span><span> people = &quot;</span><span style="color:#a3be8c;">Rustaceans</span><span>&quot;;
</span><span>format!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{people}</span><span style="color:#a3be8c;">!</span><span>&quot;);       </span><span style="color:#65737e;">// =&gt; &quot;Hello Rustaceans!&quot;
</span><span>format!(&quot;</span><span style="color:#d08770;">{} {}</span><span>&quot;, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>);           </span><span style="color:#65737e;">// =&gt; &quot;1 2&quot;
</span><span style="color:#65737e;">// 使用宽度和填充选项。`:04` 表示输出应该至少有 4 个字符宽，不足的部分用 0 填充。
</span><span>format!(&quot;</span><span style="color:#d08770;">{:04}</span><span>&quot;, </span><span style="color:#d08770;">42</span><span>);             </span><span style="color:#65737e;">// =&gt; 带前导零的 &quot;0042&quot;
</span><span style="color:#65737e;">// 使用美化的 Debug 格式。`:#?` 指示符会以更易读的多行格式输出复杂类型。
</span><span>format!(&quot;</span><span style="color:#d08770;">{:#?}</span><span>&quot;, (</span><span style="color:#d08770;">100</span><span>, </span><span style="color:#d08770;">200</span><span>));     </span><span style="color:#65737e;">// =&gt; &quot;(
</span><span>                                  </span><span style="color:#65737e;">// 100,
</span><span>                                  </span><span style="color:#65737e;">//       200, )&quot;
</span><span>                                  </span><span style="color:#65737e;">//
</span></code></pre>
<h4 id="write"><code>write!</code></h4>
<p><code>write!</code> 和 <code>writeln!</code> 是两个宏，用于将格式字符串发送到指定的流。这用于防止格式字符串的中间分配，而是直接写入输出。 在底层，这个函数实际上是调用在 <code>std::io::Write</code> 和 <code>std::fmt::Write</code> trait 上定义的 <code>write_fmt</code> 函数。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">allow</span><span>(unused)]
</span><span>#![</span><span style="color:#bf616a;">allow</span><span>(unused_must_use)]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::io::Write;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> w = Vec::new();
</span><span>    write!(&amp;mut w, &quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">world</span><span>&quot;);
</span><span>}
</span></code></pre>
<h4 id="print"><code>print!</code></h4>
<p><code>print!</code> 和 <code>println!</code> 是两个宏，用于将格式字符串发送到 <code>stdout</code>。与 <code>write!</code> 宏类似，这些宏的目标是避免在打印输出时进行中间分配。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>print!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">world</span><span>&quot;);
</span><span>println!(&quot;</span><span style="color:#a3be8c;">I have a newline </span><span style="color:#d08770;">{}</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">character at the end</span><span>&quot;);
</span></code></pre>
<p><code>eprint!</code> 和 <code>eprintln!</code> 宏分别与 <code>print!</code> 和 <code>println!</code> 相同，只不过它们将其输出发送到 <code>stderr</code>。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>eprint!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, x); 
</span><span>eprintln!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, x);
</span></code></pre>
<h4 id="format-args"><code>format_args!</code></h4>
<p><code>format_args!</code> 是一个奇怪的宏，用于安全地传递描述格式字符串的不透明对象。该对象不需要创建任何堆分配，并且仅引用栈上的信息。 在幕后，所有相关的宏都在此方面实现。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">allow</span><span>(unused)]
</span><span>#![</span><span style="color:#bf616a;">allow</span><span>(unused_must_use)]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::fmt;
</span><span>    </span><span style="color:#b48ead;">use </span><span>std::io::{</span><span style="color:#bf616a;">self</span><span>, Write};
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> some_writer = io::stdout();
</span><span>    write!(
</span><span>        &amp;mut some_writer,
</span><span>        &quot;</span><span style="color:#d08770;">{}</span><span>&quot;,
</span><span>        format_args!(&quot;</span><span style="color:#a3be8c;">print with a {}</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">macro</span><span>&quot;)
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">my_fmt_fn</span><span>(</span><span style="color:#bf616a;">args</span><span>: fmt::Arguments&lt;&#39;_&gt;) {
</span><span>        write!(&amp;mut io::stdout(), &quot;</span><span style="color:#d08770;">{args}</span><span>&quot;);
</span><span>    }
</span><span>    </span><span style="color:#96b5b4;">my_fmt_fn</span><span>(format_args!(&quot;</span><span style="color:#a3be8c;">, or a {} too</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">function</span><span>&quot;));
</span><span>}
</span><span>
</span><span style="color:#65737e;">// output: print with a macro, or a function too
</span></code></pre>
<p><code>format_args!</code> 宏的结果是 <code>fmt::Arguments</code> 类型的值。 然后可以将此结构体传递到此模块内部的 <code>write</code> 和 <code>format</code> 函数，以处理格式字符串。该宏的目的是在处理格式化字符串时甚至进一步防止中间分配。</p>
<h4 id="debug">Debug</h4>
<p>使用 <code>#[derive(Debug)]</code> 属性可以使类型自动实现 <code>Debug</code> trait。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>DebugPrintable(</span><span style="color:#b48ead;">i32</span><span>);
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> v = DebugPrintable(</span><span style="color:#d08770;">3</span><span>);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{:?}</span><span>&quot;, v);
</span><span>}
</span><span>
</span><span style="color:#65737e;">// output: DebugPrintable(3)
</span></code></pre>
<p>所有 <code>std</code> 库类型都天生可以使用 <code>{:?}</code> 来打印。</p>
<h4 id="display">Display</h4>
<p><code>fmt::Debug</code> 通常看起来不太简洁，因此自定义输出的外观经常是更可取的。这需要通过手动实现 <code>fmt::Display</code> 来做到。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::fmt;
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>List(Vec&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;);
</span><span>
</span><span style="color:#b48ead;">impl </span><span>fmt::Display </span><span style="color:#b48ead;">for </span><span>List {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fmt</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">f</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>fmt::Formatter) -&gt; fmt::Result {
</span><span>        </span><span style="color:#b48ead;">let</span><span> vet = &amp;</span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#d08770;">0</span><span>;
</span><span>        write!(f, &quot;</span><span style="color:#a3be8c;">[</span><span>&quot;)?;
</span><span>
</span><span>        </span><span style="color:#b48ead;">for </span><span>(count, v) in vet.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>            </span><span style="color:#b48ead;">if</span><span> count != </span><span style="color:#d08770;">0 </span><span>{
</span><span>                write!(f, &quot;</span><span style="color:#a3be8c;">, </span><span>&quot;)?;
</span><span>            }
</span><span>            write!(f, &quot;</span><span style="color:#d08770;">{}</span><span>&quot;, v)?;
</span><span>        }
</span><span>
</span><span>        write!(f, &quot;</span><span style="color:#a3be8c;">]</span><span>&quot;)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> v = List(vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>]);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, v);
</span><span>}
</span><span>
</span><span>
</span><span style="color:#65737e;">// output: [1, 2, 3]
</span></code></pre>
<blockquote>
<p>在 Rust 中，通过 <code>&amp;self.0</code> 来获取元组结构体或新类型结构体中第一个字段的引用是很常见的模式。这种方式允许我们访问封装在<strong>自定义类型</strong>中的内部数据，同时保持了 Rust 的<strong>所有权</strong>和<strong>借用规则</strong>。这种模式在实现自定义类型的特征(如 <code>Display</code> 特征)时特别有用，因为它让我们能够以一种安全和高效的方式操作内部数据。</p>
</blockquote>
<h2 id="shu-ju-lei-xing">数据类型</h2>
<h3 id="yuan-sheng-lei-xing">原生类型</h3>
<p>变量都能够显式地给出<strong>类型说明</strong>（type annotation）。数字还可以通过<strong>后缀</strong>（suffix）或<strong>默认方式</strong>来声明类型。</p>
<ul>
<li>整型默认为 <code>i32</code> 类型，</li>
<li>浮点型默认为 <code>f64</code> 类型。</li>
</ul>
<table><thead><tr><th>类型分类</th><th>子类型</th><th>具体类型</th></tr></thead><tbody>
<tr><td>标量</td><td>有符号整数</td><td><code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code> 和 <code>isize</code>（<strong>指针宽度</strong>）</td></tr>
<tr><td>标量</td><td>无符号整数</td><td><code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code> 和 <code>usize</code>（<strong>指针宽度</strong>）</td></tr>
<tr><td>标量</td><td>浮点数</td><td><code>f32</code>、<code>f64</code></td></tr>
<tr><td>标量</td><td>字符</td><td><code>char</code>（单个 <code>Unicode</code> 字符，如 <code>'a'</code>，<code>'α'</code> 和 <code>'∞'</code>，每个都是 <strong>4</strong> 字节）</td></tr>
<tr><td>标量</td><td>布尔型</td><td><code>bool</code>（只能是 <code>true</code> 或 <code>false</code>）</td></tr>
<tr><td>标量</td><td>单元类型</td><td><code>()</code>（其唯一可能的值就是 <code>()</code> 这个空元组）</td></tr>
<tr><td>复合</td><td>元组</td><td>如 <code>(1, true)</code></td></tr>
<tr><td>复合</td><td>数组</td><td>如 <code>[1, 2, 3]</code></td></tr>
</tbody></table>
<p>原生类型之间可以通过 <code>as</code> 关键字进行显式类型转换。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> decimal = </span><span style="color:#d08770;">65.4321_</span><span style="color:#b48ead;">f32</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> integer = decimal as </span><span style="color:#b48ead;">u64</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> character = integer as </span><span style="color:#b48ead;">u8</span><span>;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Casting: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> -&gt; </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> -&gt; </span><span style="color:#d08770;">{}</span><span>&quot;, decimal, integer, character);
</span><span>}
</span></code></pre>
<h3 id="zi-mian-liang">字面量</h3>
<p>整数 <code>1</code>、浮点数 <code>1.2</code>、字符 <code>'a'</code>、字符串 <code>"abc"</code>、布尔值 <code>true</code> 和单元类型 <code>()</code> 可以用数字、文字或符号之类的 “<strong>字面量</strong>”（literal）来表示。</p>
<p>另外，通过加前缀 <code>0x</code>、<code>0o</code>、<code>0b</code>，数字可以用十六进制、八进制或二进制记法表示。</p>
<p>为了改善可读性，可以在数值字面量中插入下划线，比如：<code>1_000</code> 等同于 <code>1000</code>，<code>0.000_001</code> 等同于 <code>0.000001</code>。</p>
<h3 id="yuan-zu">元组</h3>
<p>元组是一个可以包含各种类型值的组合。元组使用括号 <code>()</code> 来构造（construct），而每个元组自身又是一个类型标记为 <code>(T1, T2, ...)</code> 的值，其中 <code>T1</code>、<code>T2</code> 是每个元素的类型。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 元组可以充当函数的参数和返回值
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">reverse</span><span>(</span><span style="color:#bf616a;">pair</span><span>: (</span><span style="color:#bf616a;">i32</span><span>, </span><span style="color:#bf616a;">bool</span><span>)) -&gt; (</span><span style="color:#b48ead;">bool</span><span>, </span><span style="color:#b48ead;">i32</span><span>) {
</span><span>    </span><span style="color:#65737e;">// 通过元组的下标来访问具体的值
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">first value: </span><span style="color:#d08770;">{}</span><span>&quot;,pair.</span><span style="color:#d08770;">0</span><span>);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">second value: </span><span style="color:#d08770;">{}</span><span>&quot;,pair.</span><span style="color:#d08770;">1</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// 创建单元素元组需要一个额外的逗号，这是为了和被括号包含的字面量作区分。
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">one element tuple: </span><span style="color:#d08770;">{:?}</span><span>&quot;, (</span><span style="color:#d08770;">5</span><span style="color:#b48ead;">u32</span><span>,));
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">just an integer: </span><span style="color:#d08770;">{:?}</span><span>&quot;, (</span><span style="color:#d08770;">5</span><span style="color:#b48ead;">u32</span><span>));
</span><span>
</span><span>    </span><span style="color:#65737e;">// 元组可以被解构（deconstruct），从而将值绑定给变量
</span><span>    </span><span style="color:#b48ead;">let </span><span>(integer, boolean) = pair;
</span><span>    (boolean, integer)
</span><span>}
</span></code></pre>
<h3 id="shu-zu-he-qie-pian">数组和切片</h3>
<p>数组（array）是一组拥有相同类型 <code>T</code> 的对象的集合，在内存中是连续存储的。数组使用中括号 <code>[]</code> 来创建，且它们的<strong>大小在编译时会被确定</strong>。数组的类型标记为 <code>[T; length]</code>（<code>T</code> 为元素类型，<code>length</code> 表示数组大小）。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 定长数组（类型标记是多余的）
</span><span>    </span><span style="color:#b48ead;">let</span><span> xs: [</span><span style="color:#b48ead;">i32</span><span>; </span><span style="color:#d08770;">5</span><span>] = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>];
</span><span>    </span><span style="color:#65737e;">// 所有元素可以初始化成相同的值
</span><span>    </span><span style="color:#b48ead;">let</span><span> ys: [</span><span style="color:#b48ead;">i32</span><span>; </span><span style="color:#d08770;">500</span><span>] = [</span><span style="color:#d08770;">0</span><span>; </span><span style="color:#d08770;">500</span><span>];
</span><span>    </span><span style="color:#65737e;">// 数组是在栈中分配的
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">array occupies </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> bytes</span><span>&quot;, mem::size_of_val(&amp;xs));
</span><span>}
</span></code></pre>
<p>切片（slice）类型和数组类似，但其<strong>大小在编译时是不确定</strong>。</p>
<p>切片是一个双字对象（two-word object），</p>
<ul>
<li>第一个字是一个指向数据的指针，</li>
<li>第二个字是切片的长度。(“字” 的宽度和 <code>usize</code> 相同。)</li>
</ul>
<p>slice 可以用来借用数组的一部分,类型标记为 <code>&amp;[T]</code>。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::mem;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> xs: [</span><span style="color:#b48ead;">i32</span><span>; </span><span style="color:#d08770;">5</span><span>] = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>];
</span><span>    </span><span style="color:#65737e;">// 数组可以自动被借用成为 slice
</span><span>    </span><span style="color:#96b5b4;">analyze_slice</span><span>(&amp;xs);
</span><span>    </span><span style="color:#65737e;">// slice 可以指向数组的一部分
</span><span>    </span><span style="color:#96b5b4;">analyze_slice</span><span>(&amp;xs[</span><span style="color:#d08770;">1</span><span>..</span><span style="color:#d08770;">4</span><span>]);
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 此函数借用一个 slice
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">analyze_slice</span><span>(</span><span style="color:#bf616a;">slice</span><span>: &amp;[</span><span style="color:#b48ead;">i32</span><span>]) {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">first element of the slice: </span><span style="color:#d08770;">{}</span><span>&quot;, slice[</span><span style="color:#d08770;">0</span><span>]);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">the slice has </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> elements</span><span>&quot;, slice.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>}
</span></code></pre>
<h3 id="lei-xing-zhuan-huan">类型转换</h3>
<h4 id="from-into">From/Into</h4>
<p>Rust 使用 <code>trait</code> 解决类型之间的转换问题。最一般的转换会用到 <code>From</code> 和 <code>Into</code> 两个 <code>trait</code>。</p>
<blockquote>
<p>不过，即便常见的情况也可能会用到特别的 <code>trait</code>，尤其是从 <code>String</code> 转换到别的类型，以及把别的类型转换到 <code>String</code> 时。</p>
</blockquote>
<p><code>From</code> trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。</p>
<p><code>Into</code> trait 就是把 <code>From</code> trait 倒过来，为自定义类型实现 <code>From</code> 的同时，就自动获得了 <code>Intro</code>。<strong>使用 <code>Into</code> trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它</strong>。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::convert::From;
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug)]
</span><span style="color:#b48ead;">struct </span><span>Number {
</span><span>    </span><span style="color:#bf616a;">value</span><span>: </span><span style="color:#b48ead;">i32</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>From&lt;</span><span style="color:#b48ead;">i32</span><span>&gt; </span><span style="color:#b48ead;">for </span><span>Number {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">from</span><span>(</span><span style="color:#bf616a;">value</span><span>: </span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#b48ead;">Self </span><span>{ value }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> my_str = &quot;</span><span style="color:#a3be8c;">hello</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> _my_string = String::from(my_str);
</span><span>
</span><span>    </span><span style="color:#65737e;">// 自定义类型实现 From trait。
</span><span>    </span><span style="color:#b48ead;">let</span><span> num = Number::from(</span><span style="color:#d08770;">30</span><span>);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">My number is </span><span style="color:#d08770;">{:?}</span><span>&quot;, num);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> int = </span><span style="color:#d08770;">5</span><span>;
</span><span>    </span><span style="color:#65737e;">// Number 这个类型声明是必须的。
</span><span>    </span><span style="color:#b48ead;">let</span><span> num: Number = int.</span><span style="color:#96b5b4;">into</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">My number is </span><span style="color:#d08770;">{:?}</span><span>&quot;, num);
</span><span>}
</span></code></pre>
<h4 id="tryfrom-tryinto">TryFrom/TryInto</h4>
<p><code>TryFrom</code> 和 <code>TryInto</code> 是类型转换的<strong>通用</strong> trait。不同于 <code>From/Into</code> ，<code>TryFrom/TryInto</code> 用于易出错的转换，因此其返回值是 <code>Result</code> 型。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::convert::TryFrom;
</span><span style="color:#b48ead;">use </span><span>std::convert::TryInto;
</span><span>
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug, PartialEq)]
</span><span style="color:#b48ead;">struct </span><span>EvenNumber(</span><span style="color:#b48ead;">i32</span><span>);
</span><span>
</span><span style="color:#b48ead;">impl </span><span>TryFrom&lt;</span><span style="color:#b48ead;">i32</span><span>&gt; </span><span style="color:#b48ead;">for </span><span>EvenNumber {
</span><span>    </span><span style="color:#b48ead;">type </span><span>Error = String;
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">try_from</span><span>(</span><span style="color:#bf616a;">value</span><span>: </span><span style="color:#b48ead;">i32</span><span>) -&gt; std::result::Result&lt;</span><span style="color:#b48ead;">Self</span><span>, </span><span style="color:#b48ead;">Self::</span><span>Error&gt; {
</span><span>        </span><span style="color:#b48ead;">if</span><span> value % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>            Ok(EvenNumber(value))
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            Err(String::from(&quot;</span><span style="color:#a3be8c;">The number is not even!</span><span>&quot;))
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// TryFrom
</span><span>    assert_eq!(EvenNumber::try_from(</span><span style="color:#d08770;">8</span><span>), Ok(EvenNumber(</span><span style="color:#d08770;">8</span><span>)));
</span><span>    assert_eq!(
</span><span>        EvenNumber::try_from(</span><span style="color:#d08770;">5</span><span>),
</span><span>        Err(&quot;</span><span style="color:#a3be8c;">The number is not even!</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>())
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#65737e;">// TryInto
</span><span>    </span><span style="color:#b48ead;">let</span><span> result: Result&lt;EvenNumber, String&gt; = </span><span style="color:#d08770;">8</span><span style="color:#b48ead;">i32</span><span>.</span><span style="color:#96b5b4;">try_into</span><span>();
</span><span>    assert_eq!(result, Ok(EvenNumber(</span><span style="color:#d08770;">8</span><span>)));
</span><span>    </span><span style="color:#b48ead;">let</span><span> result: Result&lt;EvenNumber, String&gt; = </span><span style="color:#d08770;">5</span><span style="color:#b48ead;">i32</span><span>.</span><span style="color:#96b5b4;">try_into</span><span>();
</span><span>    assert_eq!(result, Err(&quot;</span><span style="color:#a3be8c;">The number is not even!</span><span>&quot;.</span><span style="color:#96b5b4;">to_string</span><span>()));
</span><span>}
</span></code></pre>
<h4 id="tostring">ToString</h4>
<p>要把任何类型转换成 <code>String</code>，只需要实现那个类型的 <code>ToString</code> trait，通常不直接这么做，应该实现 <code>fmt::Display</code> trait，它会自动提供 <code>ToString</code>。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::{fmt, string::ToString};
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Circle {
</span><span>    </span><span style="color:#bf616a;">radius</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>fmt::Display </span><span style="color:#b48ead;">for </span><span>Circle {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fmt</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">f</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>fmt::Formatter) -&gt; fmt::Result {
</span><span>        write!(f, &quot;</span><span style="color:#a3be8c;">Circle of radius </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#bf616a;">self</span><span>.radius)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 这是直接实现 std::string::ToString 这个 trait。
</span><span style="color:#65737e;">// impl ToString for Circle {
</span><span style="color:#65737e;">//     fn to_string(&amp;self) -&gt; String {
</span><span style="color:#65737e;">//         format!(&quot;Circle of radius {}&quot;, self.radius)
</span><span style="color:#65737e;">//     }
</span><span style="color:#65737e;">// }
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> circle = Circle { radius: </span><span style="color:#d08770;">6.0 </span><span>};
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, circle.</span><span style="color:#96b5b4;">to_string</span><span>());
</span><span>}
</span></code></pre>
<h4 id="fromstr">FromStr</h4>
<p>只要对目标类型实现了 <code>std::str::FromStr</code> trait，就可以用 <code>parse()</code> 把字符串转换成目标类型。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 使用类型注解，声明待转换的类型
</span><span>    </span><span style="color:#b48ead;">let</span><span> parsed: </span><span style="color:#b48ead;">i32 </span><span>= &quot;</span><span style="color:#a3be8c;">5</span><span>&quot;.</span><span style="color:#96b5b4;">parse</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#65737e;">// 使用 &lt;&gt;，声明待转换的类型
</span><span>    </span><span style="color:#b48ead;">let</span><span> turbo_parsed = &quot;</span><span style="color:#a3be8c;">5</span><span>&quot;.parse::&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Sum: </span><span style="color:#d08770;">{}</span><span>&quot;, parsed + turbo_parsed);
</span><span>}
</span></code></pre>
<h2 id="jie-gou-ti-he-mei-ju">结构体和枚举</h2>
<h3 id="struct">struct</h3>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 单元结构体
</span><span style="color:#b48ead;">struct </span><span>Unit;
</span><span>
</span><span style="color:#65737e;">// 元组结构体
</span><span style="color:#b48ead;">struct </span><span>Pair(</span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#b48ead;">i32</span><span>);
</span><span>
</span><span style="color:#65737e;">// 带有字段的常规结构体
</span><span style="color:#b48ead;">struct </span><span>Person {
</span><span>    </span><span style="color:#bf616a;">name</span><span>: String,
</span><span>    </span><span style="color:#bf616a;">age</span><span>: </span><span style="color:#b48ead;">u8</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 初始化单元结构体
</span><span>    </span><span style="color:#b48ead;">let</span><span> unit = Unit;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 初始化元组结构体
</span><span>    </span><span style="color:#b48ead;">let</span><span> pair = Pair(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>);
</span><span>    </span><span style="color:#65737e;">// 解构元组结构体
</span><span>    </span><span style="color:#b48ead;">let</span><span> Pair(integer, decimal) = pair;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">pair contains </span><span style="color:#d08770;">{:?}</span><span style="color:#a3be8c;"> and </span><span style="color:#d08770;">{:?}</span><span>&quot;, integer, decimal);
</span><span>    </span><span style="color:#65737e;">// 访问元组结构体
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">pair contains </span><span style="color:#d08770;">{:?}</span><span style="color:#a3be8c;"> and </span><span style="color:#d08770;">{:?}</span><span>&quot;, pair.</span><span style="color:#d08770;">0</span><span>, pair.</span><span style="color:#d08770;">1</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// 初始化结构体
</span><span>    </span><span style="color:#b48ead;">let</span><span> alice = Person {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">Alice</span><span>&quot;),
</span><span>        age: </span><span style="color:#d08770;">20</span><span>,
</span><span>    };
</span><span>    </span><span style="color:#65737e;">// 访问结构体的字段
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> is </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> years old.</span><span>&quot;, alice.name, alice.age);
</span><span>    </span><span style="color:#65737e;">// 使用结构体更新语法创建新结构体
</span><span>    </span><span style="color:#b48ead;">let</span><span> bob = Person {
</span><span>        name: String::from(&quot;</span><span style="color:#a3be8c;">Bob</span><span>&quot;),
</span><span>        ..alice
</span><span>    };
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> is </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> years old.</span><span>&quot;, bob.name, bob.age);
</span><span>}
</span></code></pre>
<p>单元结构体的使用示例：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 作为标记类型
</span><span style="color:#b48ead;">struct </span><span>Kilometers;
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">convert_to_miles</span><span>(</span><span style="color:#bf616a;">value</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">_unit</span><span>: Kilometers) -&gt; </span><span style="color:#b48ead;">f64 </span><span>{
</span><span>    value * </span><span style="color:#d08770;">1000 </span><span>as </span><span style="color:#b48ead;">f64
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 实现 traits
</span><span style="color:#b48ead;">trait </span><span>Printable {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">print</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Logger;
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Printable </span><span style="color:#b48ead;">for </span><span>Logger {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">print</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Logging...</span><span>&quot;);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> logger = Logger;
</span><span>    logger.</span><span style="color:#96b5b4;">print</span><span>();
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 零大小类型
</span><span style="color:#b48ead;">use </span><span>std::mem;
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Empty;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Size of Empty: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> bytes</span><span>&quot;, mem::size_of::&lt;Empty&gt;());
</span><span>}
</span></code></pre>
<h3 id="enum">enum</h3>
<p>enum 关键字允许创建一个从数个不同取值中选其一的枚举类型（enumeration）。任何一个在 struct 中合法的取值在 enum 中也合法。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">allow</span><span>(dead_code)] </span><span style="color:#65737e;">// 屏蔽未使用代码的警告
</span><span style="color:#b48ead;">enum </span><span>WebEvent {
</span><span>    PageLoad,                 </span><span style="color:#65737e;">// 单元结构体
</span><span>    PageUnload,               </span><span style="color:#65737e;">// 单元结构体
</span><span>    Paste(String),            </span><span style="color:#65737e;">// 元组结构体
</span><span>    Click { x: </span><span style="color:#b48ead;">i64</span><span>, y: </span><span style="color:#b48ead;">i64 </span><span>}, </span><span style="color:#65737e;">// 常规结构体
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">inspect</span><span>(</span><span style="color:#bf616a;">event</span><span>: WebEvent) {
</span><span>    </span><span style="color:#b48ead;">match</span><span> event {
</span><span>        WebEvent::PageLoad =&gt; println!(&quot;</span><span style="color:#a3be8c;">page loaded</span><span>&quot;),
</span><span>        WebEvent::PageUnload =&gt; println!(&quot;</span><span style="color:#a3be8c;">page unloaded</span><span>&quot;),
</span><span>        </span><span style="color:#65737e;">// 从 enum 中解构出值
</span><span>        WebEvent::Paste(s) =&gt; println!(&quot;</span><span style="color:#a3be8c;">pasted </span><span style="color:#d08770;">{}</span><span>&quot;, s),
</span><span>        WebEvent::Click { x, y } =&gt; println!(&quot;</span><span style="color:#a3be8c;">clicked at </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, </span><span style="color:#d08770;">{}</span><span>&quot;, x, y),
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 类型别名
</span><span>#[</span><span style="color:#bf616a;">allow</span><span>(non_camel_case_types)] </span><span style="color:#65737e;">// 屏蔽非驼峰命名的警告
</span><span style="color:#b48ead;">type </span><span>Event = WebEvent;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> _load = Event::PageLoad;
</span><span>}
</span></code></pre>
<p>可以用 <code>type</code> 语句给已有的类型取个新的名字。类型的名字必须遵循驼峰命名法（像是 CamelCase 这样），否则编译器将给出警告。</p>
<p><strong>别名的主要用途是避免写出冗长的模版化代码</strong>。</p>
<h3 id="chang-liang">常量</h3>
<p>Rust 有两种常量，可以在任意作用域声明，包括全局作用域。它们都需要显式的类型声明：</p>
<ul>
<li><code>const</code>：不可改变的值。</li>
<li><code>static</code>：具有 <code>'static</code> 生命周期的，是可变的变量（须使用 <code>static mut</code> 关键字）。</li>
</ul>
<blockquote>
<p>有个特例就是 "<code>string</code>" 字面量。它可以不经改动就被赋给一个 <code>static</code> 变量，因为它的类型标记：<code>&amp;'static str</code> 就包含了所要求的生命周期 <code>'static</code>。其他的引用类型都必须特地声明，使之拥有 <code>'static</code> 生命周期。这两种引用类型的差异似乎也无关紧要，因为无论如何，<code>static</code> 变量都得显式地声明。</p>
</blockquote>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 全局变量是在所有其他作用域之外声明的。
</span><span style="color:#b48ead;">static </span><span style="color:#d08770;">LANGUAGE</span><span>: &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>= &quot;</span><span style="color:#a3be8c;">Rust</span><span>&quot;;
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">THRESHOLD</span><span>: </span><span style="color:#b48ead;">i32 </span><span>= </span><span style="color:#d08770;">10</span><span>;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">LANGUAGE: </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#d08770;">LANGUAGE</span><span>);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">THRESHOLD: </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#d08770;">THRESHOLD</span><span>);
</span><span>}
</span></code></pre>
<h2 id="bian-liang">变量</h2>
<p>Rust 通过静态类型确保类型安全。变量绑定可以在声明时说明类型，使用 <code>let</code> 绑定操作可以将值（比如<strong>字面量</strong>）绑定（bind）到<strong>变量</strong>。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> an_integer = </span><span style="color:#d08770;">1</span><span style="color:#b48ead;">u32</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> a_boolean = </span><span style="color:#d08770;">true</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> unit = ();
</span><span>
</span><span>    </span><span style="color:#65737e;">// 将 `an_integer` 复制到 `copied_integer`。
</span><span>    </span><span style="color:#b48ead;">let</span><span> copied_integer = an_integer;
</span><span>    </span><span style="color:#65737e;">// 编译器会对未使用的变量绑定产生警告；可以给变量名加上下划线前缀来消除警告。
</span><span>    </span><span style="color:#b48ead;">let</span><span> _unused_variable = </span><span style="color:#d08770;">3</span><span style="color:#b48ead;">u32</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 变量绑定默认是不可变的， `mut` 关键字使其可变。
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> mutable_binding = </span><span style="color:#d08770;">1</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 先声明变量绑定
</span><span>    </span><span style="color:#b48ead;">let</span><span> a_binding;
</span><span>    </span><span style="color:#65737e;">// 再初始化，编译器禁止使用未经初始化的变量。
</span><span>    a_binding = </span><span style="color:#d08770;">2</span><span>; 
</span><span>}
</span></code></pre>
<p>变量绑定有一个作用域（scope），它被限定只在一个<strong>代码块</strong>（block）中生存（live）。 代码块是一个被 <code>{}</code> 包围的语句集合。另外也允许变量遮蔽（variable shadowing）。</p>
<h3 id="dong-jie">冻结</h3>
<p>当数据被相同的名称不变地绑定时，它还会冻结（freeze）。在不可变绑定超出作用域之前，无法修改已冻结的数据：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> _mutable_integer = </span><span style="color:#d08770;">7</span><span style="color:#b48ead;">i32</span><span>;
</span><span>
</span><span>    {
</span><span>        </span><span style="color:#65737e;">// 被不可变的 `_mutable_integer` 遮蔽
</span><span>        </span><span style="color:#b48ead;">let</span><span> _mutable_integer = _mutable_integer;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// `_mutable_integer` 在这个作用域没有冻结
</span><span>    _mutable_integer = </span><span style="color:#d08770;">3</span><span>;
</span><span>}
</span></code></pre>
<h2 id="kong-zhi-liu">控制流</h2>
<h3 id="if-else">if/else</h3>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> n = </span><span style="color:#d08770;">5</span><span>;
</span><span>    </span><span style="color:#b48ead;">if</span><span> n &lt; </span><span style="color:#d08770;">0 </span><span>{
</span><span>        print!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> is negative</span><span>&quot;, n);
</span><span>    } </span><span style="color:#b48ead;">else if</span><span> n &gt; </span><span style="color:#d08770;">0 </span><span>{
</span><span>        print!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> is positive</span><span>&quot;, n);
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        print!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> is zero</span><span>&quot;, n);
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="xun-huan">循环</h3>
<h4 id="loop">loop</h4>
<p><code>loop</code> 关键字来表示一个无限循环。</p>
<ul>
<li>使用 <code>break</code> 语句在任何时候退出一个循环，</li>
<li>使用 <code>continue</code> 跳过循环体的剩余部分并开始下一轮循环。</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">allow</span><span>(unreachable_code)]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    &#39;outer: </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Entered the outer loop</span><span>&quot;);
</span><span>        &#39;inner: </span><span style="color:#b48ead;">loop </span><span>{
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">Entered the inner loop</span><span>&quot;);
</span><span>            </span><span style="color:#b48ead;">break</span><span>; </span><span style="color:#65737e;">// 这只是中断内部的循环
</span><span>            </span><span style="color:#b48ead;">break &#39;outer</span><span>; </span><span style="color:#65737e;">// 这会中断外层循环
</span><span>        }
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">This point will never be reached</span><span>&quot;);
</span><span>    }
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Exited the outer loop</span><span>&quot;);
</span><span>}
</span></code></pre>
<p><code>loop</code> 有个用途是尝试一个操作直到成功为止。</p>
<p>若操作返回一个值，则可能需要将其传递给代码的其余部分：将该值放在 <code>break</code> 之后，它就会被 <code>loop</code> 表达式返回。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> counter = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        counter += </span><span style="color:#d08770;">1</span><span>;
</span><span>        </span><span style="color:#b48ead;">if</span><span> counter == </span><span style="color:#d08770;">10 </span><span>{
</span><span>            </span><span style="color:#b48ead;">break</span><span> counter * </span><span style="color:#d08770;">2</span><span>;
</span><span>        }
</span><span>    };
</span><span>    assert_eq!(result, </span><span style="color:#d08770;">20</span><span>);
</span><span>}
</span></code></pre>
<h4 id="while">while</h4>
<p><code>while</code> 关键字可以用作当型循环（<strong>当条件满足时循环</strong>）。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> n = </span><span style="color:#d08770;">3</span><span>;
</span><span>    </span><span style="color:#b48ead;">while</span><span> n &lt; </span><span style="color:#d08770;">5 </span><span>{
</span><span>        n += </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>    assert_eq!(n, </span><span style="color:#d08770;">5</span><span>);
</span><span>}
</span></code></pre>
<h4 id="for">for</h4>
<p><code>for in</code> 结构可以遍历一个 <code>Iterator</code>（迭代器）。</p>
<p>将集合转变为迭代器，有如下三个函数，分别以不同方式返回结合中的数据。</p>
<ul>
<li><code>into_iter()</code>：会消耗集合。在每次迭代中，集合中的数据本身会被提供。<strong>一旦集合被消耗了，之后就无法再使用了</strong>，因为它已经在循环中被 “移除”（move）了。</li>
<li><code>iter()</code>：在每次迭代中<strong>借用</strong>集合中的一个元素。这样集合本身不会被改变，<strong>循环之后仍可以使用</strong>。</li>
<li><code>iter_mut()</code>：<strong>可变地</strong>（mutably）借用集合中的每个元素，从而允许集合被就地修改。</li>
</ul>
<p>如果没有特别指定，<code>for</code> 循环会对给出的集合应用 <code>into_iter()</code> 函数，把它转换成一个迭代器。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 使用区间标记 a..b（前闭后开），创建一个迭代器
</span><span>    </span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">1</span><span>..</span><span style="color:#d08770;">11 </span><span>{
</span><span>        println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, i)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 使用区间标记 a..=b（前闭后闭），创建一个迭代器
</span><span>    </span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">1</span><span>..=</span><span style="color:#d08770;">10 </span><span>{
</span><span>        println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, i)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> names = vec![&quot;</span><span style="color:#a3be8c;">Bob</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Frank</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Ferris</span><span>&quot;];
</span><span>    </span><span style="color:#65737e;">// 相当于默认使用 names.into_iter()
</span><span>    </span><span style="color:#b48ead;">for</span><span> name in names {
</span><span>        </span><span style="color:#b48ead;">match</span><span> name {
</span><span>            &quot;</span><span style="color:#a3be8c;">Ferris</span><span>&quot; =&gt; println!(&quot;</span><span style="color:#a3be8c;">There is a rustacean among us!</span><span>&quot;)
</span><span>            _=&gt; println!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span>&quot;, name)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> name in names.</span><span style="color:#96b5b4;">iter</span><span>() {
</span><span>        </span><span style="color:#b48ead;">match</span><span> name {
</span><span>            &quot;</span><span style="color:#a3be8c;">Ferris</span><span>&quot; =&gt; println!(&quot;</span><span style="color:#a3be8c;">There is a rustacean among us!</span><span>&quot;)
</span><span>            _=&gt; println!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span>&quot;, name)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> name in names.</span><span style="color:#96b5b4;">iter_mut</span><span>() {
</span><span>        *name = </span><span style="color:#b48ead;">match</span><span> name {
</span><span>            &amp;</span><span style="color:#b48ead;">mut </span><span>&quot;</span><span style="color:#a3be8c;">Ferris</span><span>&quot; =&gt; println!(&quot;</span><span style="color:#a3be8c;">There is a rustacean among us!</span><span>&quot;),
</span><span>            - =&gt; println!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span>&quot;, name)
</span><span>        }
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">names: </span><span style="color:#d08770;">{:?}</span><span>&quot;, names);
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="match">match</h3>
<h4 id="mo-shi-pi-pei">模式匹配</h4>
<p>Rust 通过 <code>match</code> 关键字来提供<strong>模式匹配</strong>，和 <code>switch</code> 用法类似。第一个匹配的分支会被比对，并且<strong>所有可能的值都必须被覆盖</strong>。</p>
<pre data-lang="Rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-Rust "><code class="language-Rust" data-lang="Rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> number = </span><span style="color:#d08770;">13</span><span>;
</span><span>    </span><span style="color:#b48ead;">match</span><span> number {
</span><span>        </span><span style="color:#d08770;">1 </span><span>=&gt; println!(&quot;</span><span style="color:#a3be8c;">One</span><span>&quot;),                    </span><span style="color:#65737e;">// 匹配单个值
</span><span>        </span><span style="color:#d08770;">2 </span><span>| </span><span style="color:#d08770;">3 </span><span>| </span><span style="color:#d08770;">5 </span><span>| </span><span style="color:#d08770;">7 </span><span>| </span><span style="color:#d08770;">11 </span><span>=&gt; println!(&quot;</span><span style="color:#a3be8c;">Prime</span><span>&quot;), </span><span style="color:#65737e;">// 匹配多个值
</span><span>        </span><span style="color:#d08770;">13</span><span>..=</span><span style="color:#d08770;">19 </span><span>=&gt; println!(&quot;</span><span style="color:#a3be8c;">A teen</span><span>&quot;),           </span><span style="color:#65737e;">// 匹配闭区间
</span><span>        _ =&gt; println!(&quot;</span><span style="color:#a3be8c;">Ain&#39;t special</span><span>&quot;),          </span><span style="color:#65737e;">// 匹配任意值
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> boolean = </span><span style="color:#d08770;">true</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> binary = </span><span style="color:#b48ead;">match</span><span> boolean {
</span><span>        </span><span style="color:#d08770;">false </span><span>=&gt; </span><span style="color:#d08770;">0</span><span>,
</span><span>        </span><span style="color:#d08770;">true </span><span>=&gt; </span><span style="color:#d08770;">1</span><span>,
</span><span>    };
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> -&gt; </span><span style="color:#d08770;">{}</span><span>&quot;, boolean, binary);
</span><span>}
</span></code></pre>
<h4 id="jie-gou-pi-pei">解构匹配</h4>
<p><code>match</code> 代码块能以多种方式解构匹配，如元组、枚举、指针、引用等。</p>
<blockquote>
<p>对指针来说，<strong>解构</strong>（destructure）和<strong>解引用</strong>（dereference）要区分开，因为这两者的概念是不同的。</p>
<ul>
<li>解引用使用 <code>*</code></li>
<li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li>
</ul>
</blockquote>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">allow</span><span>(dead_code)]
</span><span style="color:#b48ead;">enum </span><span>Color {
</span><span>    Red,
</span><span>    Blue,
</span><span>    Green,
</span><span>    </span><span style="color:#d08770;">RGB</span><span>(</span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>),
</span><span>    </span><span style="color:#d08770;">HSV</span><span>(</span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>),
</span><span>    </span><span style="color:#d08770;">HSL</span><span>(</span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>),
</span><span>    </span><span style="color:#d08770;">CMY</span><span>(</span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>),
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 解构元组
</span><span>    </span><span style="color:#b48ead;">let</span><span> triple = (-</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>);
</span><span>    </span><span style="color:#b48ead;">match</span><span> triple {
</span><span>        </span><span style="color:#65737e;">// 解构出第二个和第三个元素
</span><span>        (-</span><span style="color:#d08770;">1</span><span>, y, z) =&gt; println!(&quot;</span><span style="color:#a3be8c;">First is `0`, `y` is </span><span style="color:#d08770;">{:?}</span><span style="color:#a3be8c;">, and `z` is </span><span style="color:#d08770;">{:?}</span><span>&quot;, y, z),
</span><span>        </span><span style="color:#65737e;">// .. 用于忽略元组其他部分
</span><span>        (</span><span style="color:#d08770;">1</span><span>, ..) =&gt; println!(&quot;</span><span style="color:#a3be8c;">First is `1`, and the rest doesn&#39;t matter</span><span>&quot;),
</span><span>        _ =&gt; println!(&quot;</span><span style="color:#a3be8c;">It doesn&#39;t matter what values are in the tuple</span><span>&quot;),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 解构枚举
</span><span>    </span><span style="color:#b48ead;">let</span><span> color = Color::</span><span style="color:#d08770;">RGB</span><span>(</span><span style="color:#d08770;">122</span><span>, </span><span style="color:#d08770;">17</span><span>, </span><span style="color:#d08770;">40</span><span>);
</span><span>    </span><span style="color:#b48ead;">match</span><span> color {
</span><span>        Color::Red =&gt; println!(&quot;</span><span style="color:#a3be8c;">The color is Red!</span><span>&quot;),
</span><span>        Color::</span><span style="color:#d08770;">RGB</span><span>(r, g, b) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Red </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> Green </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;"> Blue </span><span style="color:#d08770;">{}</span><span>&quot;, r, g, b),
</span><span>        _ =&gt; println!(),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> reference = &amp;</span><span style="color:#d08770;">4</span><span>;
</span><span>    </span><span style="color:#65737e;">// 解构引用（注意：与解引用区分开）
</span><span>    </span><span style="color:#b48ead;">match</span><span> reference {
</span><span>        </span><span style="color:#65737e;">// 带上引用符号 &amp; 去匹配
</span><span>        &amp;val =&gt; println!(&quot;</span><span style="color:#a3be8c;">Got a value via destructuring: </span><span style="color:#d08770;">{:?}</span><span>&quot;, val),
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 解引用（注意：与解构引用区分开）
</span><span>    </span><span style="color:#b48ead;">match </span><span>*reference {
</span><span>        </span><span style="color:#65737e;">// 直接匹配值
</span><span>        val =&gt; println!(&quot;</span><span style="color:#a3be8c;">Got a value via dereferencing: </span><span style="color:#d08770;">{:?}</span><span>&quot;, val),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 定义一个非引用类型的变量 `_not_reference` 的类型是 `i32`
</span><span>    </span><span style="color:#b48ead;">let</span><span> _not_reference = </span><span style="color:#d08770;">3</span><span>;
</span><span>    </span><span style="color:#65737e;">// 使用 `ref` 关键字，创建引用类型的变量 `_is_reference` 的类型是 `&amp;i32`
</span><span>    </span><span style="color:#b48ead;">let ref</span><span> _is_reference = </span><span style="color:#d08770;">3</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// 解构非引用类型
</span><span>    </span><span style="color:#b48ead;">let</span><span> value = </span><span style="color:#d08770;">5</span><span>;
</span><span>    </span><span style="color:#b48ead;">match</span><span> value {
</span><span>        </span><span style="color:#65737e;">// 使用 `ref` 关键字，创建引用类型的变量 `r` 的类型是 `&amp;i32`
</span><span>        </span><span style="color:#b48ead;">ref</span><span> r =&gt; println!(&quot;</span><span style="color:#a3be8c;">Got a reference to a value: </span><span style="color:#d08770;">{:?}</span><span>&quot;, r),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 解构可变类型
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> value = </span><span style="color:#d08770;">5</span><span>;
</span><span>    </span><span style="color:#b48ead;">match</span><span> value {
</span><span>        </span><span style="color:#65737e;">// 使用 `ref mut` 关键字，创建可变引用类型的变量 `r` 的类型是 `&amp;mut i32`
</span><span>        </span><span style="color:#b48ead;">ref mut</span><span> m =&gt; {
</span><span>            *m += </span><span style="color:#d08770;">10</span><span>;
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">We added 10. `value` is now </span><span style="color:#d08770;">{:?}</span><span>&quot;, m)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 解构结构体
</span><span>    </span><span style="color:#b48ead;">struct </span><span>Foo {
</span><span>        </span><span style="color:#bf616a;">x</span><span>: (</span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#b48ead;">u32</span><span>),
</span><span>        </span><span style="color:#bf616a;">y</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">let</span><span> foo = Foo { x: (</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>), y: </span><span style="color:#d08770;">3 </span><span>};
</span><span>    </span><span style="color:#b48ead;">match</span><span> foo {
</span><span>        Foo { x: (</span><span style="color:#d08770;">1</span><span>, b), y } =&gt; println!(&quot;</span><span style="color:#a3be8c;">First of x is 1, b = </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">,  y = </span><span style="color:#d08770;">{} </span><span>&quot;, b, y),
</span><span>        _ =&gt; println!(&quot;</span><span style="color:#a3be8c;">Other</span><span>&quot;),
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 解构结构体并重命名变量，顺序不重要
</span><span>    </span><span style="color:#b48ead;">let</span><span> Foo { y: i, x: j } = foo;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">i = </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, j = </span><span style="color:#d08770;">{:?}</span><span>&quot;, i, j);
</span><span>    </span><span style="color:#65737e;">// 忽略结构体中的某些变量
</span><span>    </span><span style="color:#b48ead;">let</span><span> Foo { y, .. } = foo;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">y = </span><span style="color:#d08770;">{}</span><span>&quot;, y);
</span><span>}
</span></code></pre>
<h4 id="shou-wei">守卫</h4>
<p>加上 <code>match</code> <strong>守卫语句</strong>（<code>guard</code>） 来过滤分支。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> pair = (</span><span style="color:#d08770;">2</span><span>, -</span><span style="color:#d08770;">2</span><span>);
</span><span>    </span><span style="color:#b48ead;">match</span><span> pair {
</span><span>        (x, y) </span><span style="color:#b48ead;">if</span><span> x == y =&gt; println!(&quot;</span><span style="color:#a3be8c;">equal</span><span>&quot;),
</span><span>        (x, _) </span><span style="color:#b48ead;">if</span><span> x % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">1 </span><span>=&gt; println!(&quot;</span><span style="color:#a3be8c;">The first one is odd</span><span>&quot;),
</span><span>        _ =&gt; println!(&quot;</span><span style="color:#a3be8c;">No match</span><span>&quot;),
</span><span>    }
</span><span>}
</span></code></pre>
<h4 id="bang-ding">绑定</h4>
<p>绑定是 Rust 中 <code>match</code> 表达式的一个强大特性。它允许我们在匹配模式的同时<strong>捕获</strong>和<strong>命名</strong>匹配的值。这在处理复杂数据结构或需要在匹配臂中使用匹配值时特别有用。</p>
<p>绑定使用 <code>@</code> 符号来实现。基本语法是 <code>name @ pattern</code>：</p>
<ul>
<li><code>name</code> 是想给匹配值赋予的名称，</li>
<li><code>pattern</code> 是要匹配的模式。</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">age</span><span>() -&gt; </span><span style="color:#b48ead;">u32 </span><span>{
</span><span>    </span><span style="color:#d08770;">15
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">some_number</span><span>() -&gt; Option&lt;</span><span style="color:#b48ead;">u32</span><span>&gt; {
</span><span>    Some(</span><span style="color:#d08770;">10</span><span>)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">age</span><span>() {
</span><span>        </span><span style="color:#d08770;">0 </span><span>=&gt; println!(&quot;</span><span style="color:#a3be8c;">not born yet</span><span>&quot;),
</span><span>        </span><span style="color:#65737e;">// 在匹配区间的时候，使用 @ 来间接获取值
</span><span>        n @ </span><span style="color:#d08770;">1</span><span>..=</span><span style="color:#d08770;">12 </span><span>=&gt; println!(&quot;</span><span style="color:#a3be8c;">age </span><span style="color:#d08770;">{:?}</span><span>&quot;, n),
</span><span>        n =&gt; println!(&quot;</span><span style="color:#a3be8c;">age </span><span style="color:#d08770;">{:?}</span><span>&quot;, n),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">some_number</span><span>() {
</span><span>        </span><span style="color:#65737e;">// 匹配 Some 中的值，并绑定到 n
</span><span>        Some(n @ </span><span style="color:#d08770;">42</span><span>) =&gt; println!(&quot;</span><span style="color:#a3be8c;">number: </span><span style="color:#d08770;">{}</span><span>&quot;, n),
</span><span>        </span><span style="color:#65737e;">// 匹配 Some 中的任意值
</span><span>        Some(n) =&gt; println!(&quot;</span><span style="color:#a3be8c;">number: </span><span style="color:#d08770;">{}</span><span>&quot;, n),
</span><span>        _ =&gt; println!(&quot;</span><span style="color:#a3be8c;">no match</span><span>&quot;),
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="if-let">if let</h3>
<p><code>if let</code> 是 Rust 中一种<strong>简洁的模式匹配方式</strong>，主要用于只关心<strong>一种匹配情况</strong>的场景。它通常用于替代 <code>match</code> 表达式，特别是当我们只需要匹配一个模式并忽略其他情况时。</p>
<p><code>if let 模式 = 表达式 { 代码块 } else { 可选的 else 代码块 }</code></p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">enum </span><span>Color {
</span><span>    Bar,
</span><span>    </span><span style="color:#d08770;">RGB</span><span>(</span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#b48ead;">u8</span><span>),
</span><span>    </span><span style="color:#d08770;">HSV</span><span>(</span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#b48ead;">u8</span><span>),
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> some_value = Some(</span><span style="color:#d08770;">5</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// 使用 match
</span><span>    </span><span style="color:#b48ead;">match</span><span> some_value {
</span><span>        Some(x) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Got a value: </span><span style="color:#d08770;">{}</span><span>&quot;, x),
</span><span>        None =&gt; (),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 使用 if let，更简洁，只关心一种匹配情况
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(x) = some_value {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Got a value: </span><span style="color:#d08770;">{}</span><span>&quot;, x);
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Didn&#39;t get a value</span><span>&quot;);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 匹配任意枚举值
</span><span>    </span><span style="color:#b48ead;">let</span><span> color = Color::</span><span style="color:#d08770;">RGB</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">160</span><span>, </span><span style="color:#d08770;">255</span><span>);
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Color::</span><span style="color:#d08770;">RGB</span><span>(r, g, b) = color {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">RGB color: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, </span><span style="color:#d08770;">{}</span><span>&quot;, r, g, b);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> a = Color::Bar;
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Color::Bar = a {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Bar</span><span>&quot;);
</span><span>    }
</span><span>}
</span></code></pre>
<blockquote>
<p>另一个好处是：<code>if let</code> 允许匹配枚举非参数化的变量，即枚举未注明 <code>#[derive(PartialEq)]</code>，也没有为其实现 <code>PartialEq</code>。在这种情况下，通常 <code>if Foo::Bar == a</code> 会<strong>出错</strong>，因为此类枚举的实例不具有可比性。但是，<code>if let Foo::Bar = a</code> 是<strong>可行</strong>的。</p>
</blockquote>
<h3 id="while-let">while let</h3>
<p><code>while let</code> 是 Rust 中的一种循环结构，它结合了 <code>while</code> 循环和<strong>模式匹配</strong>的特性。这个结构允许<strong>在某个模式持续匹配时重复执行代码块</strong>。</p>
<p><code>while let 模式 = 表达式 { 代码块 }</code></p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> optional = Some(</span><span style="color:#d08770;">0</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// 使用传统的 while 循环
</span><span>    </span><span style="color:#b48ead;">while</span><span> optional.</span><span style="color:#96b5b4;">is_some</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> value = optional.</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">got: </span><span style="color:#d08770;">{}</span><span>&quot;, value);
</span><span>        optional = </span><span style="color:#b48ead;">if</span><span> value &lt; </span><span style="color:#d08770;">5 </span><span>{ Some(value + </span><span style="color:#d08770;">1</span><span>) } </span><span style="color:#b48ead;">else </span><span>{ None };
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 使用 while let 更简洁，避免显示 unwrap()，减少运行时错误的风险
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> optional = Some(</span><span style="color:#d08770;">0</span><span>);
</span><span>    </span><span style="color:#b48ead;">while let </span><span>Some(value) = optional {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">got: </span><span style="color:#d08770;">{}</span><span>&quot;, value);
</span><span>        optional = </span><span style="color:#b48ead;">if</span><span> value &lt; </span><span style="color:#d08770;">5 </span><span>{ Some(value + </span><span style="color:#d08770;">1</span><span>) } </span><span style="color:#b48ead;">else </span><span>{ None };
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// 结合 mut 变量
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> values = vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>];
</span><span>    </span><span style="color:#b48ead;">while let </span><span>Some(</span><span style="color:#b48ead;">mut</span><span> value) = values.</span><span style="color:#96b5b4;">pop</span><span>() {
</span><span>        value *= </span><span style="color:#d08770;">2</span><span>;
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Current value: </span><span style="color:#d08770;">{}</span><span>&quot;, value);
</span><span>    }
</span><span>}
</span></code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li><code>while let</code> 没有可选的 <code>else/else if</code> 分支。</li>
<li><code>while let</code> 不会自动实现 <code>break</code> 或 <code>continue</code>。如果需要这些控制流，需要显式地使用它们。</li>
<li>如果模式匹配失败，循环会立即结束。确保你的逻辑考虑到了这一点。</li>
</ul>
</blockquote>
<h2 id="han-shu">函数</h2>
<p>函数（function）使用 <code>fn</code> 关键字来声明。<strong>函数的参数需要标注类型</strong>，就和变量一样，如果函数返回一个值，返回类型必须在箭头 <code>-&gt;</code> 之后指定。</p>
<p><strong>函数最后的表达式将作为返回值</strong>。也可以在函数内使用 <code>return</code> 语句来提前返一个值，甚至可以在循环或 <code>if</code> 内部使用。</p>
<ul>
<li>一个 “不” 返回值的函数。实际上会返回一个单元类型 <code>()</code>。</li>
<li>当函数返回 <code>()</code> 时，函数签名可以省略返回类型</li>
</ul>
<h3 id="fang-fa">方法</h3>
<p>方法（method）是依附于对象的函数。这些方法通过关键字 <code>self</code> 来访问对象中的数据和其他。方法在 <code>impl</code> 代码块中定义。</p>
<table><thead><tr><th>特征</th><th>静态方法</th><th>实例方法</th></tr></thead><tbody>
<tr><td>定义方式</td><td>在 <code>impl</code> 块中，不以 <code>self</code> 作为第一个参数</td><td>在 <code>impl</code> 块中，第一个参数是 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code></td></tr>
<tr><td>调用语法</td><td>使用双冒号 <code>::</code> 通过类型名调用</td><td>使用点号 <code>.</code> 通过实例调用</td></tr>
<tr><td>示例调用</td><td><code>String::new()</code>, <code>Vec::&lt;i32&gt;::new()</code></td><td><code>some_string.len()</code>, <code>some_vec.push(1)</code></td></tr>
<tr><td>是否需要实例</td><td>不需要实例即可调用</td><td>需要实例才能调用</td></tr>
<tr><td>常见用途</td><td>构造函数、工厂方法、辅助函数</td><td>操作实例数据、实现对象行为</td></tr>
<tr><td><code>self</code> 关键字</td><td>不使用 <code>self</code></td><td>使用 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code></td></tr>
<tr><td>返回 <code>Self</code></td><td>可以返回 <code>Self</code> 表示当前类型</td><td>通常不返回 <code>Self</code>，但可以</td></tr>
<tr><td>访问实例数据</td><td>不能直接访问实例数据</td><td>可以访问实例数据</td></tr>
</tbody></table>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>Rectangle {
</span><span>    </span><span style="color:#bf616a;">width</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>    </span><span style="color:#bf616a;">height</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Rectangle {
</span><span>    </span><span style="color:#65737e;">// 静态方法（关联函数）
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">width</span><span>: </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#bf616a;">height</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#b48ead;">Self </span><span>{ width, height }
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 实例方法，`&amp;self` 是 `self: &amp;Self` 的语法糖
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">area</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">u32 </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.width * </span><span style="color:#bf616a;">self</span><span>.height
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 实例方法，`self` 是 `self: Self` 的语法糖
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">compare</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">other</span><span>: &amp;Rectangle) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>        </span><span style="color:#bf616a;">self</span><span>.width &gt; other.width &amp;&amp; </span><span style="color:#bf616a;">self</span><span>.height &gt; other.height
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 要求调用者是可变的，`&amp;mut self` 为 `self: &amp;mut Self` 的语法糖
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">translate</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">y</span><span>: </span><span style="color:#b48ead;">f64</span><span>) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.p1.x += x;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.p2.x += x;
</span><span>
</span><span>        </span><span style="color:#bf616a;">self</span><span>.p1.y += y;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.p2.y += y;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 调用静态方法
</span><span>    </span><span style="color:#b48ead;">let</span><span> rect = Rectangle::new(</span><span style="color:#d08770;">10</span><span>, </span><span style="color:#d08770;">20</span><span>);
</span><span>    </span><span style="color:#65737e;">// 调用实例方法
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Area: </span><span style="color:#d08770;">{}</span><span>&quot;, rect.</span><span style="color:#96b5b4;">area</span><span>());
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> square = Rectangle {
</span><span>        width: </span><span style="color:#d08770;">1.0</span><span>,
</span><span>        height: </span><span style="color:#d08770;">2.0</span><span>,
</span><span>    };
</span><span>    square.</span><span style="color:#96b5b4;">translate</span><span>(</span><span style="color:#d08770;">10.0</span><span>, </span><span style="color:#d08770;">20.0</span><span>);
</span><span>}
</span></code></pre>
<h3 id="bi-bao">闭包</h3>
<p>Rust 中的闭包（closure），也叫做 lambda 表达式是一类<strong>能够捕获周围作用域中变量的函数</strong>。</p>
<blockquote>
<p>闭包表达式产生的类型就是 “<strong>闭包类型</strong>”，不属于引用类型。</p>
</blockquote>
<table><thead><tr><th>特性</th><th>函数</th><th>闭包</th></tr></thead><tbody>
<tr><td>语法</td><td>使用 <code>fn</code> 关键字定义</td><td>使用 <code>|参数| { 函数体 }</code> 形式</td></tr>
<tr><td>类型推断</td><td>需要显式声明参数和返回值类型</td><td>可以根据上下文推断类型</td></tr>
<tr><td>捕获环境</td><td>不能捕获定义环境中的变量</td><td>可以捕获定义环境中的变量</td></tr>
<tr><td>存储和传递</td><td>可以直接存储在变量中或作为参数传递</td><td>需要使用特定的 trait（<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>）</td></tr>
<tr><td>生命周期</td><td>没有特定的生命周期限制</td><td>受捕获变量的生命周期影响</td></tr>
<tr><td>定义位置</td><td>可以在全局作用域中定义</td><td>通常在局部作用域中定义</td></tr>
<tr><td>重载</td><td>可以重载（通过不同的函数名）</td><td>不能重载</td></tr>
<tr><td>递归</td><td>可以直接递归调用自身</td><td>需要特殊处理才能实现递归，如使用 <code>Rc&lt;RefCell&lt;&gt;&gt;</code> 或 <code>Box&lt;dyn Fn()&gt;</code></td></tr>
</tbody></table>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 函数
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">add_one</span><span>(</span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">i32 </span><span>{
</span><span>    x + </span><span style="color:#d08770;">1
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 闭包
</span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">add_one </span><span>= |</span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">i32</span><span>| -&gt; </span><span style="color:#b48ead;">i32 </span><span>{ x + </span><span style="color:#d08770;">1 </span><span>};
</span></code></pre>
<h4 id="bu-huo-bian-liang">捕获变量</h4>
<p>闭包可以通过以下方式捕获变量，即实现了不通的 <code>trait</code>：</p>
<ul>
<li>如果闭包只是读取变量，通过不可变引用：<code>&amp;T</code> 捕获；即实现了 <code>Fn</code> trait：此闭包可以多次调用而<strong>不改变</strong>捕获的环境。</li>
<li>如果闭包需要修改变量，通过可变引用：<code>&amp;mut T</code> 捕获；即实现了 <code>FnMut</code> trait：此闭包可以多次调用并<strong>改变</strong>捕获的环境。</li>
<li>如果闭包需要获取所有权或者变量类型不支持复制，通过值：<code>T</code> 捕获； 即实现了 <code>FnOnce</code> trait：此闭包理论上可以被多次调用，但是由于它会消耗捕获的值，所以通常只能被调用一次。</li>
</ul>
<p><strong>闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。</strong></p>
<blockquote>
<p>闭包的 <code>trait</code> 是层级关系：<code>Fn</code> 是 <code>FnMut</code> 的子 <code>trait</code>，<code>FnMut</code> 是 <code>FnOnc</code>e 的子 <code>trait</code>。这意味着：</p>
<p>实现了 <code>Fn</code> 的闭包也实现了 <code>FnMut</code> 和 <code>FnOnce</code>
实现了 <code>FnMut</code> 的闭包也实现了 <code>FnOnce</code></p>
</blockquote>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 根据对捕获变量的不同操作，闭包实现的 trait 不同。
</span><span>
</span><span>    </span><span style="color:#65737e;">// Fn()
</span><span>    </span><span style="color:#b48ead;">let</span><span> color = String::from(&quot;</span><span style="color:#a3be8c;">green</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">print </span><span>= || println!(&quot;</span><span style="color:#a3be8c;">color: </span><span style="color:#d08770;">{}</span><span>&quot;, color);
</span><span>    </span><span style="color:#96b5b4;">print</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// FnMut()
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> count = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut </span><span style="color:#8fa1b3;">inc </span><span>= || {
</span><span>        count += </span><span style="color:#d08770;">1</span><span>;
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">count: </span><span style="color:#d08770;">{}</span><span>&quot;, count)
</span><span>    };
</span><span>    </span><span style="color:#96b5b4;">inc</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// FnOnce()
</span><span>    </span><span style="color:#b48ead;">let</span><span> movable = Box::new(</span><span style="color:#d08770;">3</span><span>);
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">consume </span><span>= || {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">`movable`: </span><span style="color:#d08770;">{:?}</span><span>&quot;, movable);
</span><span>        std::mem::drop(movable); </span><span style="color:#65737e;">// 将 movable 回收掉
</span><span>    };
</span><span>    </span><span style="color:#96b5b4;">consume</span><span>();
</span><span>}
</span></code></pre>
<p>在竖线 <code>|</code> 之前使用 <code>move</code> 会强制闭包取得<strong>被捕获变量的所有权</strong>：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> x = vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>];
</span><span style="color:#b48ead;">let</span><span> equal_to_x = </span><span style="color:#b48ead;">move </span><span>|z: Vec&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;| z == x;
</span></code></pre>
<h4 id="zuo-wei-shu-ru-he-shu-chu-can-shu">作为输入和输出参数</h4>
<p>目前 Rust 只支持返回具体（非泛型）的类型。按照定义，匿名的闭包的类型是未知的，所以只有使用 <code>impl Trait</code> 才能返回一个闭包。还必须使用 <code>move</code> 关键字，表明所有的捕获都是通过值进行的。<strong>这是必须的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。</strong></p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 输入参数
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">apply</span><span>&lt;F&gt;(</span><span style="color:#bf616a;">f</span><span>: F) -&gt; </span><span style="color:#b48ead;">i32
</span><span style="color:#b48ead;">where
</span><span>    F: FnOnce() -&gt; </span><span style="color:#b48ead;">i32</span><span>,
</span><span>{
</span><span>    </span><span style="color:#96b5b4;">f</span><span>()
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 输出参数
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_fn</span><span>() -&gt; impl Fn() {
</span><span>    </span><span style="color:#65737e;">// str 不需要额外的内存分配，是一个引用，
</span><span>    </span><span style="color:#65737e;">// 不涉及所有权转移，是不可变的，有轻微的性能优势
</span><span>    </span><span style="color:#b48ead;">let str</span><span>: &amp;</span><span style="color:#b48ead;">&#39;static str </span><span>= &quot;</span><span style="color:#a3be8c;">Fn</span><span>&quot;;
</span><span>    </span><span style="color:#b48ead;">let</span><span> text: String = &quot;</span><span style="color:#a3be8c;">Fn</span><span>&quot;.</span><span style="color:#96b5b4;">to_owned</span><span>();
</span><span>    </span><span style="color:#b48ead;">move </span><span>|| println!(&quot;</span><span style="color:#a3be8c;">str: </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">, text: </span><span style="color:#d08770;">{}</span><span>&quot;, </span><span style="color:#b48ead;">str</span><span>, text)
</span><span>}
</span></code></pre>
<h4 id="bi-bao-zhong-mo-shi-pi-pei">闭包中模式匹配</h4>
<p>以下这三种写法都是正确的，但第二种（使用 <code>&amp;x</code>）通常被认为是最简洁和惯用的。</p>
<p>重要的是要理解，这里的 <code>&amp;</code> 在模式匹配中的作用与在其他上下文中的作用不同：</p>
<ul>
<li>在表达式中，<code>&amp;</code> 用于创建引用。</li>
<li>在模式中，<code>&amp;</code> 用于匹配引用并解引用。</li>
</ul>
<p>这种双重用途可能初看起来有点混淆，但它是 Rust 模式匹配系统的一个强大特性，允许我们以一种非常灵活和表达性强的方式处理数据结构。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> number = vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>];
</span><span>    </span><span style="color:#65737e;">// 使用 &amp;x（不解引用）
</span><span>    numbers.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">any</span><span>(|</span><span style="color:#bf616a;">x</span><span>| *x % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0</span><span>)
</span><span>    </span><span style="color:#65737e;">// 使用 &amp;x（解引用）
</span><span>    numbers.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">any</span><span>(|&amp;</span><span style="color:#bf616a;">x</span><span>| x % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0</span><span>)
</span><span>    </span><span style="color:#65737e;">// 不使用模式匹配（显式解引用）
</span><span>    numbers.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">any</span><span>(|</span><span style="color:#bf616a;">x</span><span>| (*x) % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0</span><span>)
</span><span>}
</span></code></pre>
<p>Rust 中闭包参数的模式匹配和解引用，为什么要这样做？</p>
<ul>
<li>便利性：这允许我们在闭包体内直接使用 <code>x</code> 作为一个 <code>i32</code>，而不需要每次都写 <code>*x</code>。</li>
<li>简洁性：它使代码更加简洁和易读。</li>
<li>灵活性：这种模式匹配允许我们根据需要选择是使用引用还是值。</li>
</ul>
<h3 id="gao-jie-han-shu">高阶函数</h3>
<p>Rust 中的高阶函数体现了<strong>函数式编程</strong>的特性。高阶函数是指可以接受一个或多个函数作为参数，和/或返回一个函数的函数。</p>
<p>优点：</p>
<ul>
<li>代码复用：高阶函数允许抽象通用的操作模式。</li>
<li>灵活性：可以在运行时动态选择和组合行为。</li>
<li>表达力：能够简洁地表达复杂的操作。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>性能：虽然 Rust 的零成本抽象通常能够优化高阶函数，但在某些情况下可能会有轻微的性能开- 销。</li>
<li>可读性：过度使用高阶函数可能会降低代码的可读性。</li>
<li>生命周期：当使用引用时，需要注意生命周期的问题。</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 自定义高阶函数
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">apply_twice</span><span>&lt;F&gt;(</span><span style="color:#bf616a;">f</span><span>: F, </span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">i32
</span><span style="color:#b48ead;">where
</span><span>    F: Fn(</span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">i32</span><span>,
</span><span>{
</span><span>    </span><span style="color:#96b5b4;">f</span><span>(</span><span style="color:#96b5b4;">f</span><span>(x))
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_adder</span><span>(</span><span style="color:#bf616a;">y</span><span>: </span><span style="color:#b48ead;">i32</span><span>) -&gt; impl Fn(</span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">i32 </span><span>{
</span><span>    </span><span style="color:#b48ead;">move </span><span>|x| x + y
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 函数指针
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_with_one</span><span>(</span><span style="color:#bf616a;">f</span><span>: </span><span style="color:#b48ead;">fn</span><span>(</span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">i32 </span><span>{
</span><span>    </span><span style="color:#96b5b4;">f</span><span>(</span><span style="color:#d08770;">1</span><span>)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">add_one</span><span>(</span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">i32 </span><span>{
</span><span>    x + </span><span style="color:#d08770;">1
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> numbers = vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>];
</span><span>    </span><span style="color:#65737e;">// 常见高阶函数 map、filter、fold
</span><span>    </span><span style="color:#b48ead;">let</span><span> _squares: Vec&lt;</span><span style="color:#b48ead;">i32</span><span>&gt; = numbers.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">map</span><span>(|&amp;</span><span style="color:#bf616a;">x</span><span>| x * x).</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> _even_numbers: Vec&lt;&amp;</span><span style="color:#b48ead;">i32</span><span>&gt; = numbers.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">filter</span><span>(|&amp;&amp;</span><span style="color:#bf616a;">x</span><span>| x % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0</span><span>).</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> _sum: </span><span style="color:#b48ead;">i32 </span><span>= numbers.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">fold</span><span>(</span><span style="color:#d08770;">0</span><span>, |</span><span style="color:#bf616a;">acc</span><span>, &amp;</span><span style="color:#bf616a;">x</span><span>| acc + x);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">double </span><span>= |</span><span style="color:#bf616a;">x</span><span>| x * </span><span style="color:#d08770;">2</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#96b5b4;">apply_twice</span><span>(double, </span><span style="color:#d08770;">5</span><span>);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, result); </span><span style="color:#65737e;">// 输出：20
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> adder = </span><span style="color:#96b5b4;">create_adder</span><span>(</span><span style="color:#d08770;">2</span><span>);
</span><span>    </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#96b5b4;">adder</span><span>(</span><span style="color:#d08770;">3</span><span>);
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, result); </span><span style="color:#65737e;">// 输出：5
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> res = </span><span style="color:#96b5b4;">call_with_one</span><span>(add_one);
</span><span>}
</span></code></pre>
<table><thead><tr><th>特性</th><th>函数指针</th><th>闭包</th></tr></thead><tbody>
<tr><td>环境捕获</td><td>不能捕获环境</td><td>可以捕获定义环境中的变量</td></tr>
<tr><td>类型</td><td>具体类型，如 <code>fn(i32) -&gt; i32</code></td><td>实现 <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> trait</td></tr>
<tr><td>语法</td><td>使用 <code>fn</code> 关键字定义</td><td>使用 <code>|参数| 表达式</code> 语法</td></tr>
<tr><td>大小</td><td>固定大小（通常是一个机器字）</td><td>大小可变，取决于捕获的环境</td></tr>
<tr><td>使用场景</td><td>简单回调，不需要捕获环境</td><td>更灵活，适用于需要访问环境的场景</td></tr>
<tr><td>Trait 实现</td><td>自动实现所有 <code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code> trait</td><td>根据对捕获变量的使用方式实现相应 trait</td></tr>
<tr><td>分发方式</td><td>总是静态分发（编译时）</td><td>可以静态分发（泛型）或动态分发（trait 对象）</td></tr>
<tr><td>内存布局</td><td>指向代码的指针</td><td>包含捕获变量和函数指针的结构</td></tr>
<tr><td>泛型上下文</td><td>只能用于 <code>fn</code> 类型参数</td><td>可用于实现了 <code>Fn</code> 系列 trait 的类型参数</td></tr>
<tr><td>创建和存储</td><td>易于创建、存储和传递</td><td>每个闭包是唯一类型，存储和传递可能需要 trait 对象或泛型</td></tr>
</tbody></table>
<h4 id="fa-san-han-shu">发散函数</h4>
<p>发散函数是永不返回的函数。在 Rust 中，这种函数的返回类型被标记为 <code>!</code>，称为 <strong>never type</strong> 或 <strong>empty type</strong>。</p>
<blockquote>
<p>类型系统中的作用： <code>!</code> 类型是所有类型的子类型，<strong>这意味着它可以被强制转换为任何其他类型</strong>。</p>
</blockquote>
<p>特征：</p>
<ul>
<li>永不返回到调用者</li>
<li>可以用在需要任何类型的地方</li>
<li>通常用于终止程序执行或进入无限循环</li>
</ul>
<p><code>fn diverging_function() -&gt; ! { 函数体 }</code></p>
<p>常见用例：</p>
<ul>
<li>程序终止（如 <code>panic!</code> 宏）</li>
<li>持续运行的进程（如服务器主循环）</li>
<li>错误处理</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#bf616a;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">exit</span><span>() -&gt; ! {
</span><span>    std::process::exit(</span><span style="color:#d08770;">1</span><span>);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">infinite_loop</span><span>() -&gt; ! {
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        </span><span style="color:#65737e;">// 无限循环
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 与 match 结合
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">match_number</span><span>(</span><span style="color:#bf616a;">n</span><span>: </span><span style="color:#b48ead;">i32</span><span>) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>    </span><span style="color:#b48ead;">match</span><span> n {
</span><span>        </span><span style="color:#d08770;">0 </span><span>=&gt; </span><span style="color:#d08770;">false</span><span>,
</span><span>        </span><span style="color:#d08770;">1 </span><span>=&gt; </span><span style="color:#d08770;">true</span><span>,
</span><span>        _ =&gt; panic!(&quot;</span><span style="color:#a3be8c;">Unexpected number</span><span>&quot;), </span><span style="color:#65737e;">// 这里使用了发散函数
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 与 Option&lt;T&gt; 或 Result&lt;T,E&gt; 结合
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">process</span><span>(</span><span style="color:#bf616a;">data</span><span>: Option&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;) -&gt; </span><span style="color:#b48ead;">i32 </span><span>{
</span><span>    </span><span style="color:#b48ead;">match</span><span> data {
</span><span>        Some(x) =&gt; x,
</span><span>        None =&gt; panic!(&quot;</span><span style="color:#a3be8c;">No data</span><span>&quot;), </span><span style="color:#65737e;">// 发散函数用作返回值
</span><span>    }
</span><span>}
</span></code></pre>
<p>在异步编程中的应用： 在异步函数中，发散函数可以用来表示永不完成的 future。</p>
<p>注意事项：</p>
<ul>
<li>编译器会检查发散函数是否真的不会返回</li>
<li>发散函数仍然可以包含 <code>return</code> 语句，但这些语句必须也是发散的</li>
</ul>
<h2 id="suo-you-quan-he-jie-yong">所有权和借用</h2>
<p>所有权规则
引用和借用
生命周期</p>
<h2 id="te-zheng-traits">特征（Traits）</h2>
<p>trait 定义
impl Trait for Type</p>
<h2 id="cuo-wu-chu-li">错误处理</h2>
<p>Result&lt;T, E&gt;
Option
panic!</p>
<h2 id="fan-xing">泛型</h2>
<p>函数中的泛型
结构体和枚举中的泛型</p>
<h2 id="mo-kuai-xi-tong">模块系统</h2>
<h3 id="mod-guan-jian-zi">mod 关键字</h3>
<p>模块可以分配到<strong>文件</strong>/<strong>目录</strong>的层次结构中。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 此声明将会查找名为 `my.rs` 或 `my/mod.rs` 的文件，
</span><span style="color:#65737e;">// 并将该文件的内容放到此作用域中一个名为 `my` 的模块里面。
</span><span style="color:#b48ead;">mod </span><span>my;
</span><span>
</span><span style="color:#65737e;">// 类似地，`mod inaccessible` 和 `mod nested` 将找到 `nested.rs` 和
</span><span style="color:#65737e;">// `inaccessible.rs` 文件，并在它们放到各自的模块中。
</span><span style="color:#b48ead;">mod </span><span>inaccessible;
</span><span style="color:#b48ead;">pub mod </span><span>nested;
</span></code></pre>
<h3 id="use-yu-ju">use 语句</h3>
<p>use 声明可以将一个完整的路径绑定到一个新的名字，从而更容易访问。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 将 `deeply::nested::function` 路径绑定到 `other_function`。
</span><span style="color:#b48ead;">use </span><span>deeply::nested::function as other_function;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">function</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">called `function()`</span><span>&quot;);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">mod </span><span>deeply {
</span><span>    </span><span style="color:#b48ead;">pub mod </span><span>nested {
</span><span>        </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">function</span><span>() {
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">called `deeply::nested::function()`</span><span>&quot;)
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// 更容易访问 `deeply::nested::function`
</span><span>    </span><span style="color:#96b5b4;">other_function</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Entering block</span><span>&quot;);
</span><span>    {
</span><span>        </span><span style="color:#65737e;">// 这和 `use deeply::nested::function as function` 等价。
</span><span>        </span><span style="color:#65737e;">// 此 `function()` 将遮蔽外部的同名函数。
</span><span>        </span><span style="color:#b48ead;">use </span><span>deeply::nested::function;
</span><span>        </span><span style="color:#96b5b4;">function</span><span>();
</span><span>        </span><span style="color:#65737e;">// `use` 绑定拥有局部作用域。在这个例子中，`function()`
</span><span>        </span><span style="color:#65737e;">// 的遮蔽只存在这个代码块中。
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Leaving block</span><span>&quot;);
</span><span>    }
</span><span>    </span><span style="color:#96b5b4;">function</span><span>();
</span><span>}
</span><span>
</span></code></pre>
<h3 id="pub-guan-jian-zi">pub 关键字</h3>
<p>默认情况下，模块中的项拥有私有的可见性（private visibility），不过可以加上 <code>pub</code> 修饰语来重载这一行为。模块中只有公有的（public）项可以从模块外的作用域访问。</p>
<h2 id="chang-yong-biao-zhun-ku-gong-neng">常用标准库功能</h2>
<p>Vec, String 操作
文件 I/O
并发（线程）</p>
<h2 id="shu-xing">属性</h2>
<ul>
<li>当属性作用于整个 crate 时，它们的语法为 <code>#![crate_attribute]</code>，</li>
<li>当属性作用于模块或项时，语法为 <code>#[item_attribute]</code>（注意少了感叹号 !）。</li>
</ul>
<p>属性可以接受参数，有不同的语法形式：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">attribute </span><span>= &quot;</span><span style="color:#a3be8c;">value</span><span>&quot;]
</span><span>#[</span><span style="color:#bf616a;">attribute</span><span>(key = &quot;</span><span style="color:#a3be8c;">value</span><span>&quot;)]
</span><span>#[</span><span style="color:#bf616a;">attribute</span><span>(value,value2)]
</span></code></pre>
<h3 id="cfg">cfg</h3>
<p>条件编译可能通过两种不同的操作符实现：</p>
<ul>
<li>cfg 属性：在属性位置中使用 <code>#[cfg(...)]</code></li>
<li>cfg! 宏：在布尔表达式中使用 <code>cfg!(...)</code></li>
</ul>
<p>两种形式使用的参数语法都相同。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 这个函数仅当目标系统是 Linux 的时候才会编译
</span><span>#[</span><span style="color:#bf616a;">cfg</span><span>(target_os = &quot;</span><span style="color:#a3be8c;">linux</span><span>&quot;)]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">are_you_on_linux</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">You are running linux!</span><span>&quot;)
</span><span>}
</span><span>
</span><span style="color:#65737e;">// 而这个函数仅当目标系统 不是 Linux 时才会编译
</span><span>#[</span><span style="color:#bf616a;">cfg</span><span>(</span><span style="color:#bf616a;">not</span><span>(target_os = &quot;</span><span style="color:#a3be8c;">linux</span><span>&quot;))]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">are_you_on_linux</span><span>() {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">You are *not* running linux!</span><span>&quot;)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">are_you_on_linux</span><span>();
</span><span>    
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Are you sure?</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">if </span><span>cfg!(target_os = &quot;</span><span style="color:#a3be8c;">linux</span><span>&quot;) {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Yes. It&#39;s definitely linux!</span><span>&quot;);
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Yes. It&#39;s definitely *not* linux!</span><span>&quot;);
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="hong">宏</h2>
<p>macro_rules!
常用宏: println!, vec!</p>
<h2 id="yi-bu-bian-cheng">异步编程</h2>
<p>async/await
Future trait</p>

        </section>
    </article>
</main>



        

    </div>
</body>

</html>
